#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>
#include <stdint.h>
#include <sys/fcntl.h>
#include <unistd.h>
#include <sys/time.h>

#pragma pack(1)

#define DUMPERROR 0
#define WORKSIZE 65536 ///< Maximum size of compression segment
#define RANGEMAX 0x10000000000 ///< 2^40, maximum size of range

typedef struct {
	uint64_t count; ///< Number of times this symbol occurs in plaintext
	uint64_t range_start; ///< Low bounds of range
	uint64_t range_end; ///< High bounds of range
} freq_entry_t;

typedef struct {
	freq_entry_t freq[256]; ///< Frequency table, contains list of ranges for all possible symbols
	uint8_t freq_comp[1024]; ///< Compressed frequency table, either enumerated or full
	uint16_t freq_comp_len; ///< Length of compressed frequency table
	uint8_t plain[WORKSIZE]; ///< Buffer for plaintext to be compressed
	size_t plain_len; ///< Plaintext length
	uint8_t comp[WORKSIZE * 2]; ///< Buffer for compressed tokens, larger than plaintext buffer to guard against over-ratio compresions
	size_t comp_len; ///< Length of compressed token stream
	uint8_t decomp[WORKSIZE]; ///< Buffer for decompressed data
	size_t decomp_len; ///< Length of decompressed data
} carith_comp_ctx;

carith_comp_ctx test_comp;

// cbit (C bit manipulation) stuff

typedef struct {
	uint64_t byte; ///< Byte counter into buffer
	uint8_t bit; ///< Next bit to manipulate on above byte
	uint8_t *buffer; ///< Pointer to buffer we are working with
} cbit_cursor_t;

static uint8_t cbit_byte_mask[] = { 0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f }; ///< Byte mask to mask off requested bit

void cbit_write(cbit_cursor_t *a_cursor, unsigned int a_bit)
{
	// make masks
	uint8_t l_and = cbit_byte_mask[a_cursor->bit];
	uint8_t l_or = l_and ^ 0xff;

	// write bit at cursor position
	a_cursor->buffer[a_cursor->byte] &= l_and;
	if (a_bit)
		a_cursor->buffer[a_cursor->byte] |= l_or;

	// advance the cursor
	if (a_cursor->bit > 0) {
		--a_cursor->bit;
	} else {
		++a_cursor->byte;
		a_cursor->bit = 7;
	}
}

void cbit_write_many(cbit_cursor_t *a_cursor, uint64_t a_bits, uint16_t a_count)
{
	// sanity check our bit count
	if (!((a_count <= 64) && (a_count > 0))) {
		fprintf(stderr, "cbit_write_many: insane bit count of %d. bit count must between 1-64.", a_count);
		exit(EXIT_FAILURE);
	}

	// shift everything over all the way to the left
	a_bits <<= (64 - a_count);

	// feed them into write_bit one at a time.
	while (a_count > 0) {
		cbit_write(a_cursor, (a_bits & 0x8000000000000000ULL) > 0);
		a_bits <<= 1;
		--a_count;
	}
}

int cbit_read(cbit_cursor_t *a_cursor)
{
	uint8_t l_mask = cbit_byte_mask[a_cursor->bit] ^ 0xff;
	uint8_t l_byte = a_cursor->buffer[a_cursor->byte] & l_mask;

	// advance the cursor
	if (a_cursor->bit > 0) {
		--a_cursor->bit;
	} else {
		++a_cursor->byte;
		a_cursor->bit = 7;
	}

	return (l_byte > 0); // true, if the bit we requested is set
}

uint64_t cbit_read_many(cbit_cursor_t *a_cursor, uint16_t a_count)
{
	// sanity check our bit count
	if (!((a_count <= 64) && (a_count > 0))) {
		fprintf(stderr, "cbit_read_many: insane bit count of %d. bit count must between 1-64.", a_count);
		exit(EXIT_FAILURE);
	}

	uint64_t l_ret = 0;

	while (a_count > 0) {
		l_ret <<= 1;
		if (cbit_read(a_cursor) > 0)
			l_ret |= 0x0000000000000001ULL;
		--a_count;
	}
	return l_ret;
}

uint16_t cbit_bit_width(uint64_t a_val)
{
	uint16_t ret = 64;

	while (ret > 0) {
		if ((a_val & 0x8000000000000000ULL) > 0)
			return ret;
		ret--;
		a_val <<= 1;
	}
	return ret;
}

void freq_count(carith_comp_ctx *ctx)
{
	size_t i;

	for (i = 0; i < 256; ++i) {
		ctx->freq[i].count = 0;
	}
	for (i = 0; i < ctx->plain_len; ++i) {
		ctx->freq[ctx->plain[i]].count++;
	}
}

void assign_ranges(carith_comp_ctx *ctx, uint64_t a_start, uint64_t a_end)
{
	size_t i;
	uint64_t l_rangesize = a_end - a_start;
	uint64_t l_countbase = 0;
	uint64_t l_rangebase = 0;

	if (l_rangesize < 1024) {
		printf("tiny range %ld !!!!! %010lx %010lx\n", l_rangesize, a_start, a_end);
	}
	for (i = 0; i < 256; ++i) {
		if (ctx->freq[i].count > 0) {
			ctx->freq[i].range_start = a_start + l_rangebase;
			l_countbase += ctx->freq[i].count;
			l_rangebase = (l_countbase * l_rangesize) / ctx->plain_len;
			ctx->freq[i].range_end = a_start + l_rangebase - 1;
		}
	}
	printf("assign_ranges: lo %010lX hi %010lX size %ld\n", a_start, a_end, a_end - a_start);
	//	for (j = 0; j < 32; ++j) {
	//		for (i = 0; i < 8; ++i) {
	//			size_t k = (j * 8) + i;
	//			if (ctx->freq[k].count > 0) {
	//				printf("%02lX: %ld %010lX %010lX  ", k, ctx->freq[k].count, ctx->freq[k].range_start, ctx->freq[k].range_end);
	//				l++;
	//				if (l == 5) {
	//					l = 0;
	//					printf("\n");
	//				}
	//			}
	//		}
	//	}
}

void process(carith_comp_ctx *ctx)
{
	size_t plain_ptr;
	uint64_t range_lo, range_hi;
	uint8_t cur_byte;
	uint8_t range_lo_hibyte, range_hi_hibyte; // bits 32-40 of the range
	size_t comp_ptr = 0, decomp_ptr = 0;
	size_t i;
//	int found;
	uint64_t window;

	if (ctx->plain_len == 0)
		return;

	freq_count(ctx);
	range_lo = 0;
	range_hi = RANGEMAX;
	assign_ranges(ctx, range_lo, range_hi);

	for (plain_ptr = 0; plain_ptr < ctx->plain_len; ++plain_ptr) {
		cur_byte = ctx->plain[plain_ptr];
		range_lo = ctx->freq[cur_byte].range_start;
		range_hi = ctx->freq[cur_byte].range_end;
		printf("pos %ld read %02X new range_lo %010lX range_hi %010lX\n", plain_ptr, cur_byte, range_lo, range_hi);
		range_lo_hibyte = (range_lo >> 32);
		range_hi_hibyte = (range_hi >> 32);
		while (range_lo_hibyte == range_hi_hibyte) {
			printf("outputing pos %ld byte %02X\n", comp_ptr, range_lo_hibyte);
			ctx->comp[comp_ptr++] = range_lo_hibyte;
			range_lo <<= 8;
			range_lo &= 0x000000ffffffff00ULL;
			range_hi <<= 8;
			range_hi &= 0x000000ffffffff00ULL;
			range_hi |= 0xff;
			range_lo_hibyte = (range_lo >> 32);
			range_hi_hibyte = (range_hi >> 32);
		}
		assign_ranges(ctx, range_lo, range_hi);
	}
	for (i = 0; i < 5; ++i) {
		range_lo_hibyte = (range_lo >> 32) & 0xff;
//		printf("comp pos %ld outputting final 5-byte word %02X\n", comp_ptr, range_lo_hibyte);
		ctx->comp[comp_ptr++] = range_lo_hibyte;
		range_lo <<= 8;
	}
	ctx->comp_len = comp_ptr;

//	printf("process: compressed %ld bytes into %ld.\n", ctx->plain_len, ctx->comp_len);

	uint8_t ftbl_enum[1024];
	memset(ftbl_enum, 0, 1024);
	uint16_t ftbl_enum_len;
	uint16_t ftbl_enum_entries = 0;
	uint8_t ftbl_full[1024];
	memset(ftbl_full, 0, 1024);
	uint16_t ftbl_full_len;
	uint64_t countmax = 0;
	for (i = 0; i < 256; ++i) {
		if (ctx->freq[i].count > countmax)
			countmax = ctx->freq[i].count;
	}
	uint16_t countwidth = cbit_bit_width(countmax);
	cbit_cursor_t bc;

	// construct enumerated frequency table
	bc.byte = 0;
	bc.bit = 7;
	bc.buffer = ftbl_enum;
	cbit_write(&bc, 1); // first bit true indicates it's enumerated
	cbit_write_many(&bc, countwidth, 5); // value 0-31 for countwidth
	for (i = 0; i < 256; ++i) {
		if (ctx->freq[i].count > 0)
			ftbl_enum_entries++;
	}
	cbit_write_many(&bc, ftbl_enum_entries, 9); // 0-256 number of active symbols
	for (i = 0; i < 256; ++i) {
		if (ctx->freq[i].count > 0) {
			cbit_write_many(&bc, i, 8);
			cbit_write_many(&bc, ctx->freq[i].count, countwidth);
		}
	}
	if (bc.bit < 7) {
		bc.byte++;
		bc.bit = 7;
	}
	ftbl_enum_len = bc.byte;
//	printf("enumerated frequency table size: %d\n", ftbl_enum_len);

	// construct full frequency table
	bc.byte = 0;
	bc.bit = 7;
	bc.buffer = ftbl_full;
	cbit_write(&bc, 0); // first bit false indicates it's full
	cbit_write_many(&bc, countwidth, 5); // value 0-31 for countwidth
	for (i = 0; i < 256; ++i) {
		cbit_write_many(&bc, ctx->freq[i].count, countwidth);
	}
	if (bc.bit < 7) {
		bc.byte++;
		bc.bit = 7;
	}
	ftbl_full_len = bc.byte;
//	printf("full frequency table size: %d\n", ftbl_full_len);

	if (ftbl_enum_len < ftbl_full_len) {
		memcpy(ctx->freq_comp, ftbl_enum, ftbl_enum_len);
		ctx->freq_comp_len = ftbl_enum_len;
	} else {
		memcpy(ctx->freq_comp, ftbl_full, ftbl_full_len);
		ctx->freq_comp_len = ftbl_full_len;
	}
//	printf("compressed frequency table length: %d\n", ctx->freq_comp_len);
	uint64_t total_comp_len = ctx->freq_comp_len + ctx->comp_len;
	printf("===== total compressed size: %ld ratio: %3.5f%%  ", total_comp_len, (float)total_comp_len / (float)ctx->plain_len * 100.0);;

	// obliterate frequency table
	for (i = 0; i < 256; ++i) {
		ctx->freq[i].count = 0;
	}

	// read compressed frequency table
	bc.byte = 0;
	bc.bit = 7;
	bc.buffer = ctx->freq_comp;;
	int ftbl_type = cbit_read(&bc);
	if (ftbl_type == 1) {
		countwidth = cbit_read_many(&bc, 5);
		ftbl_enum_entries = cbit_read_many(&bc, 9);
//		printf("read compressed table - countwidth %d ftbl_enum_entries %ld\n", countwidth, ftbl_enum_entries);
		for (i = 0; i < ftbl_enum_entries; ++i) {
			uint8_t symbol = cbit_read_many(&bc, 8);
			uint64_t symbol_count = cbit_read_many(&bc, countwidth);
			ctx->freq[symbol].count = symbol_count;
		}
	} else {
		countwidth = cbit_read_many(&bc, 5);
		for (i = 0; i < 256; ++i) {
			ctx->freq[i].count = cbit_read_many(&bc, countwidth);
		}
	}

	// change decomp to plain once this is debugged and tested
	range_lo = 0;
	range_hi = RANGEMAX;
	assign_ranges(ctx, range_lo, range_hi);
	comp_ptr = 0;
	decomp_ptr = 0;
	// prime the pump
	window = 0;
	for (i = 0; i < 5; ++i) {
		window <<= 8;
		window |= ctx->comp[comp_ptr++];
	}

	while (1) {
//		found = 0; // keep track of whether or not we found the range. If we didn't find the range, this is a fatal error!
//		printf("comp_ptr %ld decomp_ptr %ld\n", comp_ptr, decomp_ptr);
		for (i = 0; i < 256; ++i) {
			if (ctx->freq[i].count > 0) { // don't waste time checking ranges of values that don't exist
				if ((window <= ctx->freq[i].range_end) && (window >= ctx->freq[i].range_start)) { // are we in this range?
					// output i to decomp stream
//					printf("decomp_ptr %ld outputting %02X\n", decomp_ptr, i);
					ctx->decomp[decomp_ptr++] = i;
//					found = 1;
					range_lo = ctx->freq[i].range_start;
					range_hi = ctx->freq[i].range_end;
					range_lo_hibyte = (range_lo >> 32);
					range_hi_hibyte = (range_hi >> 32);
					while (range_lo_hibyte == range_hi_hibyte) {
//						printf("hibyte equivalency %02X range_lo %010lX range_hi %010lx\n", range_lo_hibyte, range_lo, range_hi);
						// scoot our ranges over by 8 bits
						range_lo <<= 8;
						range_lo &= 0x000000ffffffff00ULL;
						range_hi <<= 8;
						range_hi &= 0x000000ffffffff00ULL;
						range_hi |= 0xff;
						// slide our window over and read next compressed byte into the low position
						window <<= 8;
						window &= 0x000000ffffffff00ULL;
						window |= ctx->comp[comp_ptr++];
						// refresh our hibyte values for the next test at top of loop
						range_lo_hibyte = (range_lo >> 32);
						range_hi_hibyte = (range_hi >> 32);
					}
					assign_ranges(ctx, range_lo, range_hi);
					break;
				}
			}
		}
//		if (found == 0) {
//			printf("range not found! %010lX\n", window);
//			exit(EXIT_FAILURE);
//		}
		if (decomp_ptr >= ctx->plain_len)
			break;
	}
	ctx->decomp_len = decomp_ptr;

	printf("== decompressed %ld bytes into %ld -- ", ctx->comp_len, ctx->decomp_len);
	int compare = memcmp(ctx->plain, ctx->decomp, ctx->plain_len);
	printf("memcmp %d\n", compare);
	if (DUMPERROR && (compare != 0)) {
		int err_fd = open("error-plain", O_RDWR | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
		write(err_fd, ctx->plain, ctx->plain_len);
		close(err_fd);
		exit(EXIT_FAILURE);
	}

//	// dick with bit cursor stuff to test
//	cbit_cursor_t bc;
//	bc.byte = 0;
//	bc.bit = 7;
//	uint8_t bcbuff[10];
//	memset(bcbuff, 0, 10);
//	bc.buffer = bcbuff;
//	cbit_write_many(&bc, 0xfed, 12);
//	cbit_write_many(&bc, 0xab, 8);
//	cbit_write_many(&bc, 0x7, 4);
//	cbit_write(&bc, 1);
//	printf("bcbuff: ");
//	for (i = 0; i < 9; ++i)
//		printf("%02X ", bcbuff[i]);
//	printf("\n");
//	uint32_t reader;
//	bc.byte = 0;
//	bc.bit = 7;
//	reader = cbit_read_many(&bc, 32);
//	printf("reader = %08X\n", reader);
}

void load_file(const char *a_path)
{
	int lf_fd;
	int res;

	lf_fd = open(a_path, O_RDONLY);
	if (lf_fd < 0) {
		fprintf(stderr, "error: open %s: %s\n", a_path, strerror(errno));
		exit(EXIT_FAILURE);
	}
	do {
		carith_comp_ctx l_ctx;
		res = read(lf_fd, l_ctx.plain, WORKSIZE);
		if (res < 0) {
			fprintf(stderr, "error: read %s: %s\n", a_path, strerror(errno));
			exit(EXIT_FAILURE);
			process(&l_ctx);
		}
		if (res == 0) continue;
		printf("%s: %d bytes read  ", a_path, res);
		l_ctx.plain_len = res;
		process(&l_ctx);
	} while (res != 0);
	close(lf_fd);
}

int listdir(const char *path) {
	struct dirent *entry;
	DIR *dp;
	int res;

	dp = opendir(path);
	if (dp == NULL) {
		perror("opendir");
		exit(EXIT_FAILURE);
	}

	while ((entry = readdir(dp)) != NULL) {
//		printf("%s: ", entry->d_name);
		struct stat l_stat;
		res = stat(entry->d_name, &l_stat);
		if (res < 0) {
			fprintf(stderr, "error: stat on %s: %s\n", entry->d_name, strerror(errno));
			exit(EXIT_FAILURE);
		}
		switch (l_stat.st_mode & S_IFMT) {
			case S_IFBLK:  printf("block device\n");            break;
			case S_IFCHR:  printf("character device\n");        break;
			case S_IFDIR:
			{
				printf("directory\n");
				//listdir(entry->d_name);
			}
			break;
			case S_IFIFO:  printf("FIFO/pipe\n");               break;
			case S_IFLNK:  printf("symlink\n");                 break;
			case S_IFREG:
			{
//				printf("regular file\n");
				load_file(entry->d_name);
			}
			break;
			case S_IFSOCK: printf("socket\n");                  break;
			default:       printf("unknown?\n");                break;
		}
	}

	closedir(dp);
	return 0;
}

int main(int argc, char **argv)
{
	struct timeval g_start_time, g_end_time;
	gettimeofday(&g_start_time, NULL);

	printf("cranger build %s release %s\nbuilt on %s\n", BUILD_NUMBER, RELEASE_NUMBER, BUILD_DATE);
	chdir(argv[1]);
	listdir(".");
	gettimeofday(&g_end_time, NULL);

	printf("completed operation in %ld seconds %ld usecs.\n",
		   g_end_time.tv_sec - g_start_time.tv_sec - ((g_end_time.tv_usec - g_start_time.tv_usec < 0) ? 1 : 0), // subtract 1 if there was a usec rollover
		g_end_time.tv_usec - g_start_time.tv_usec + ((g_end_time.tv_usec - g_start_time.tv_usec < 0) ? 1000000 : 0)); // bump usecs by 1 million usec for rollover

	return 0;
}
