<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CARITH (C Arithmetic Coder) Demonstration: lzss.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CARITH (C Arithmetic Coder) Demonstration
   </div>
   <div id="projectbrief">An implementation of Arithmetic Coding in C (with LZSS)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('lzss_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">lzss.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Lempel/Ziv/Storer/Szymanski dictionary compressor.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;arpa/inet.h&gt;</code><br />
</div>
<p><a href="lzss_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:token_5Fblock_5Ft" id="r_token_5Fblock_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtoken__block__t.html">token_block_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block of 8 tokens awaiting write to output stream.  <a href="structtoken__block__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:symbol_5Fhint_5Ft" id="r_symbol_5Fhint_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsymbol__hint__t.html">symbol_hint_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a symbol hint.  <a href="structsymbol__hint__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:lzss_5Fcomp_5Fctx" id="r_lzss_5Fcomp_5Fctx"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LZSS context.  <a href="structlzss__comp__ctx.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4942a378a89f0af5b9c1079debb1eff1" id="r_a4942a378a89f0af5b9c1079debb1eff1"><td class="memItemLeft" align="right" valign="top"><a id="a4942a378a89f0af5b9c1079debb1eff1" name="a4942a378a89f0af5b9c1079debb1eff1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a> { <b>LZSS_ERR_NONE</b>
, <b>LZSS_ERR_MEMORY</b>
, <b>LZSS_ERR_ZEROIN</b>
 }</td></tr>
<tr class="memdesc:a4942a378a89f0af5b9c1079debb1eff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumerated list of return error codes. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad57167af4c77f4c1377caa44a6acfc98" id="r_ad57167af4c77f4c1377caa44a6acfc98"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad57167af4c77f4c1377caa44a6acfc98">lzss_strerror</a> (<a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a> a_errno)</td></tr>
<tr class="memdesc:ad57167af4c77f4c1377caa44a6acfc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a char pointer to an existing error string Works in exactly the same way as the strerror(errno) function works in the standard library.  <br /></td></tr>
<tr class="memitem:ae84edf797ca2bc7c19d3f52b05331666" id="r_ae84edf797ca2bc7c19d3f52b05331666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae84edf797ca2bc7c19d3f52b05331666">lzss_prepare_dictionary</a> (<a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *ctx, const uint8_t *a_seed, size_t a_seed_len, uint8_t *a_buffer)</td></tr>
<tr class="memdesc:ae84edf797ca2bc7c19d3f52b05331666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install custom seed dictionary into buffer.  <br /></td></tr>
<tr class="memitem:a8cf63d0edc97076d5e4a80f4601e2d18" id="r_a8cf63d0edc97076d5e4a80f4601e2d18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cf63d0edc97076d5e4a80f4601e2d18">lzss_prepare_default_dictionary</a> (<a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *ctx, uint8_t *a_buffer)</td></tr>
<tr class="memdesc:a8cf63d0edc97076d5e4a80f4601e2d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install the default seed dictionary into buffer.  <br /></td></tr>
<tr class="memitem:ade5b89bc78ce6ff4122dd1426be64be5" id="r_ade5b89bc78ce6ff4122dd1426be64be5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade5b89bc78ce6ff4122dd1426be64be5">lzss_init_context</a> (<a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *ctx, size_t a_worksize)</td></tr>
<tr class="memdesc:ade5b89bc78ce6ff4122dd1426be64be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a LZSS context.  <br /></td></tr>
<tr class="memitem:a03916f3d483d703377d340eab685af9e" id="r_a03916f3d483d703377d340eab685af9e"><td class="memItemLeft" align="right" valign="top"><a id="a03916f3d483d703377d340eab685af9e" name="a03916f3d483d703377d340eab685af9e"></a>
<a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lzss_free_context</b> (<a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *ctx)</td></tr>
<tr class="memdesc:a03916f3d483d703377d340eab685af9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a LZSS context Release all allocated memory. <br /></td></tr>
<tr class="memitem:ab19fbd15e98f2d17196c614e93d2bb1b" id="r_ab19fbd15e98f2d17196c614e93d2bb1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab19fbd15e98f2d17196c614e93d2bb1b">lzss_prepare_pointer_pool</a> (<a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *ctx, uint8_t *a_in, size_t a_in_len)</td></tr>
<tr class="memdesc:ab19fbd15e98f2d17196c614e93d2bb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count symbols and build pointer pool.  <br /></td></tr>
<tr class="memitem:a3c373cc8e98d00d6ff05b01924441d49" id="r_a3c373cc8e98d00d6ff05b01924441d49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c373cc8e98d00d6ff05b01924441d49">lzss_encode</a> (<a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *ctx, uint8_t *a_in, size_t a_in_len, uint8_t *a_out, size_t *a_out_len)</td></tr>
<tr class="memdesc:a3c373cc8e98d00d6ff05b01924441d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an LZSS block.  <br /></td></tr>
<tr class="memitem:a5bb5cfac22c3d30608974d4a3f5559f6" id="r_a5bb5cfac22c3d30608974d4a3f5559f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bb5cfac22c3d30608974d4a3f5559f6">lzss_decode</a> (<a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *ctx, uint8_t *a_in, size_t a_in_len, uint8_t *a_out, size_t *a_out_len)</td></tr>
<tr class="memdesc:a5bb5cfac22c3d30608974d4a3f5559f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode an LZSS block.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lempel/Ziv/Storer/Szymanski dictionary compressor. </p>
<p>LZSS API 2025/Dec/03 - Revision 0.80 alpha</p>
<p>Created by: Stephen Sviatko</p>
<p>(C) 2025 Good Neighbors LLC - All Rights Reserved, except where noted</p>
<p>This file and any intellectual property (designs, algorithms, formulas, procedures, trademarks, and related documentation) contained herein are property of Good Neighbors, an Arizona Limited Liability Company.</p>
<p>LICENSING INFORMATION</p>
<p>This file may not be distributed in any modified form without expressed written permission of Good Neighbors LLC or its regents. Permission is granted to use this file in any non-commercial, non-governmental capacity (such as student projects, hobby projects, etc) without an official licensing agreement as long as the original author(s) are credited in any derivative work.</p>
<p>Commercial licensing of this content is available, any agreement must include consulting services as part of a deployment strategy. For more information, please contact Stephen Sviatko at the following email address:</p>
<p><a href="#" onclick="location.href='mai'+'lto:'+'ssv'+'ia'+'tko'+'@g'+'mai'+'l.'+'com'; return false;">ssvia<span class="obfuscator">.nosp@m.</span>tko@<span class="obfuscator">.nosp@m.</span>gmail<span class="obfuscator">.nosp@m.</span>.com</a></p>
<p>LZSS API </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a5bb5cfac22c3d30608974d4a3f5559f6" name="a5bb5cfac22c3d30608974d4a3f5559f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb5cfac22c3d30608974d4a3f5559f6">&#9670;&#160;</a></span>lzss_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a> lzss_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>a_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>a_in_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>a_out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>a_out_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode an LZSS block. </p>
<p>This is the main decompression routine. It takes a buffer of compression tokens as input and a buffer large enough to hold the window and the output data. Note that the window must be seeded with the same dictionary that was used to compress the data in the lzss_encode function above.</p>
<p>NOTE: Using the wrong dictionary will result in corrupt output data!</p>
<p>Same advice for output buffer size in the Encode routine applies here. it is recommended that the output buffer be 3/2 the size of expected decompressed plain text plus the size of the window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The LZSS Context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_in</td><td>Pointer to buffer containing compression tokens </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_in_len</td><td>Length of buffer containing compression tokens </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_out</td><td>Pointer to windowed buffer with appropriate seed dictionary and space for output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_out_len</td><td>The length of the output data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c373cc8e98d00d6ff05b01924441d49" name="a3c373cc8e98d00d6ff05b01924441d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c373cc8e98d00d6ff05b01924441d49">&#9670;&#160;</a></span>lzss_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a> lzss_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>a_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>a_in_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>a_out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>a_out_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode an LZSS block. </p>
<p>This is the main compression routine. It takes a buffer as input which is large enough to hold a complete window (typically 4095 bytes) plus all of the input data. For example, if the user is compressing 64k of data, then the input buffer must be capable of holding 68k (the 4k window + the 64k).</p>
<p>The window should be seeded with a pre-defined dictionary. If you have no dictionary prepared, then you should call lzss_prepare_default_dictionary before doing the symbol count with lzss_prepare_pointer_pool. Having a pre-defined seed dictionary radically improves the compression ratio on small files of 4k or less. If you choose to make your own custom dictionary, it should contain words/phrases and/or byte sequences that you imagine to be common to the data you intend to encode.</p>
<p>The output buffer must be large enough to contain all of the compression tokens, plus the 12 bytes of informational data the compressor writes at the start of the output stream. Note that an uncompressible input stream will result in writing excessive byte tokens with very few match tokens, and with a 9/8 ratio of output data to input bytes this will result in a compression ratio of around 112.5%. For this reason the output buffer should be at least 9/8ths the size of the input data, and should include additional space as a guard on the end of that. A conservtive recommendation would be to make the output buffer 3/2 the size of the input buffer. This is the size used in the lzss_test demonstration program, and it is probably overkill, but it will guarantee that you will never overrun the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The LZSS Context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_in</td><td>Pointer to buffer containing window + input data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_in_len</td><td>Length of buffer (window + input data) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_out</td><td>Pointer to buffer large enough to contain compression tokens </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_out_len</td><td>The length of the output data </td></tr>
  </table>
  </dd>
</dl>
<p>&lt; Number of bytes initially copied directly before first match</p>
<p>&lt; Number of tokens we have encoded thus far</p>
<p>&lt; Next position to write in the out buffer</p>
<p>&lt; Variable to hold match locations</p>
<p>&lt; Variable to hold match lengths, holds value MINMATCH &gt;= value &lt;= MAXMATCH</p>

</div>
</div>
<a id="ade5b89bc78ce6ff4122dd1426be64be5" name="ade5b89bc78ce6ff4122dd1426be64be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5b89bc78ce6ff4122dd1426be64be5">&#9670;&#160;</a></span>lzss_init_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a> lzss_init_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>a_worksize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a LZSS context. </p>
<p>Must be called before any other operations are attempted. This function allocates space for the internal buffers in the LZSS context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Pointer to a LZSS context object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_worksize</td><td>Size in bytes of requested compression segment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cf63d0edc97076d5e4a80f4601e2d18" name="a8cf63d0edc97076d5e4a80f4601e2d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf63d0edc97076d5e4a80f4601e2d18">&#9670;&#160;</a></span>lzss_prepare_default_dictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a> lzss_prepare_default_dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>a_buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install the default seed dictionary into buffer. </p>
<p>The default dictionary above contains the most common English words, words used in programming and other technical disciplines, and commonly repeated bytes. </p>

</div>
</div>
<a id="ae84edf797ca2bc7c19d3f52b05331666" name="ae84edf797ca2bc7c19d3f52b05331666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84edf797ca2bc7c19d3f52b05331666">&#9670;&#160;</a></span>lzss_prepare_dictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a> lzss_prepare_dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>a_seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>a_seed_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>a_buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install custom seed dictionary into buffer. </p>
<p>At the start of encoding, a typical LZSS system will have no window to call upon to find matches. It has to slowly build a window by sliding forward, and this can cause poor compression ratios in smaller files (less than 4095 bytes in length).</p>
<p>My solution to this problem is to load up a custom "seed dictionary" to fill the space to the left of the window pointer while the window is creeping forward between 0 and (typically 4095) bytes. This will give the encoder some default values to reference, and hopefully find matches quicker. </p>

</div>
</div>
<a id="ab19fbd15e98f2d17196c614e93d2bb1b" name="ab19fbd15e98f2d17196c614e93d2bb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19fbd15e98f2d17196c614e93d2bb1b">&#9670;&#160;</a></span>lzss_prepare_pointer_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a> lzss_prepare_pointer_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzss__comp__ctx.html">lzss_comp_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>a_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>a_in_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count symbols and build pointer pool. </p>
<p>Call this after calling lzss_prepare_dictionary </p>

</div>
</div>
<a id="ad57167af4c77f4c1377caa44a6acfc98" name="ad57167af4c77f4c1377caa44a6acfc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57167af4c77f4c1377caa44a6acfc98">&#9670;&#160;</a></span>lzss_strerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lzss_strerror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4942a378a89f0af5b9c1079debb1eff1">lzss_error_t</a></td>          <td class="paramname"><span class="paramname"><em>a_errno</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a char pointer to an existing error string Works in exactly the same way as the strerror(errno) function works in the standard library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_errno</td><td>The numerical error returned by the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>character pointer to error message </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="lzss_8h.html">lzss.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
